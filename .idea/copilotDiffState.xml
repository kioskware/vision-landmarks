<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/NormalizedObject.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/NormalizedObject.kt" />
              <option name="originalContent" value="package kioskware.vision.landmarks&#10;&#10;import android.graphics.RectF&#10;import kioskware.vision.landmarks.common.Normalized&#10;&#10;/**&#10; * Represents an object with coordinates in relative [0,1] coordinate system.&#10; * This is a normalized version of [Object] that implements the [Normalized] interface.&#10; *&#10; * All bounding box coordinates and landmark locations are in relative coordinates [0,1]&#10; * where (0,0) represents the top-left corner and (1,1) represents the bottom-right corner.&#10; */&#10;class NormalizedObject(&#10;    typeId: String,&#10;    trackingId: String,&#10;    bounding: RectF,&#10;    landmarks: List&lt;NormalizedLandmark&gt; = emptyList(),&#10;    objects: List&lt;NormalizedObject&gt; = emptyList(),&#10;    params: List&lt;ObjectParam&lt;*&gt;&gt; = emptyList()&#10;) : Object(typeId, trackingId, bounding, landmarks, objects, params), Normalized&#10;" />
              <option name="updatedContent" value="package kioskware.vision.landmarks&#10;&#10;import android.graphics.RectF&#10;import kioskware.vision.landmarks.common.Normalized&#10;&#10;/**&#10; * Represents an object with coordinates in relative [0,1] coordinate system.&#10; * This is a normalized version of [Object] that implements the [Normalized] interface.&#10; *&#10; * All bounding box coordinates and landmark locations are in relative coordinates [0,1]&#10; * where (0,0) represents the top-left corner and (1,1) represents the bottom-right corner.&#10; */&#10;class NormalizedObject(&#10;    typeId: String,&#10;    trackingId: String,&#10;    bounding: RectF,&#10;    val normalizedLandmarks: List&lt;NormalizedLandmark&gt; = emptyList(),&#10;    val normalizedObjects: List&lt;NormalizedObject&gt; = emptyList(),&#10;    params: List&lt;ObjectParam&lt;*&gt;&gt; = emptyList()&#10;) : Object(&#10;    typeId = typeId,&#10;    trackingId = trackingId,&#10;    bounding = bounding,&#10;    landmarks = normalizedLandmarks, // Cast is safe since NormalizedLandmark extends Landmark&#10;    objects = normalizedObjects,     // Cast is safe since NormalizedObject extends Object&#10;    params = params&#10;), Normalized" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/Object.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/Object.kt" />
              <option name="originalContent" value="package kioskware.vision.landmarks&#10;&#10;import android.graphics.RectF&#10;import kioskware.vision.landmarks.common.NormalizationConverter&#10;&#10;open class Object(&#10;    val typeId: String,&#10;    val trackingId: String,&#10;    val bounding: RectF,&#10;    val landmarks: List&lt;Landmark&gt; = emptyList(),&#10;    val objects: List&lt;Object&gt; = emptyList(),&#10;    val params: List&lt;ObjectParam&lt;*&gt;&gt; = emptyList()&#10;) {&#10;&#10;    /**&#10;     * Returns width of this object.&#10;     * Equivalent to `bounding.width`.&#10;     */&#10;    val width: Float&#10;        get() = bounding.width()&#10;&#10;    /**&#10;     * Returns height of this object.&#10;     * Equivalent to `bounding.height`.&#10;     */&#10;    val height: Float&#10;        get() = bounding.height()&#10;&#10;}&#10;&#10;/**&#10; * Extension functions for convenient conversion between Object and NormalizedObject.&#10; */&#10;&#10;/**&#10; * Converts this object from pixel coordinates to normalized relative coordinates [0,1].&#10; *&#10; * @param imageWidth The width of the image in pixels&#10; * @param imageHeight The height of the image in pixels&#10; * @param pixelDepthScale Optional scaling factor for z-coordinate conversion&#10; * @return NormalizedObject with coordinates in [0,1] range&#10; */&#10;fun Object.toNormalized(&#10;    imageWidth: Int,&#10;    imageHeight: Int,&#10;    pixelDepthScale: Float = imageWidth.toFloat()&#10;): NormalizedObject = NormalizationConverter.toNormalized(this, imageWidth, imageHeight, pixelDepthScale)&#10;&#10;/**&#10; * Converts this normalized object from relative coordinates [0,1] to pixel coordinates.&#10; *&#10; * @param imageWidth The width of the image in pixels&#10; * @param imageHeight The height of the image in pixels&#10; * @param pixelDepthScale Optional scaling factor for z-coordinate conversion&#10; * @return Object with coordinates in pixel space&#10; */&#10;fun NormalizedObject.toPixel(&#10;    imageWidth: Int,&#10;    imageHeight: Int,&#10;    pixelDepthScale: Float = imageWidth.toFloat()&#10;): Object = NormalizationConverter.toPixel(this, imageWidth, imageHeight, pixelDepthScale)&#10;&#10;" />
              <option name="updatedContent" value="package kioskware.vision.landmarks&#10;&#10;import android.graphics.RectF&#10;&#10;open class Object(&#10;    val typeId: String,&#10;    val trackingId: String,&#10;    val bounding: RectF,&#10;    val landmarks: List&lt;Landmark&gt; = emptyList(),&#10;    val objects: List&lt;Object&gt; = emptyList(),&#10;    val params: List&lt;ObjectParam&lt;*&gt;&gt; = emptyList()&#10;) {&#10;&#10;    /**&#10;     * Returns width of this object.&#10;     * Equivalent to `bounding.width`.&#10;     */&#10;    val width: Float&#10;        get() = bounding.width()&#10;&#10;    /**&#10;     * Returns height of this object.&#10;     * Equivalent to `bounding.height`.&#10;     */&#10;    val height: Float&#10;        get() = bounding.height()&#10;&#10;    /**&#10;     * Converts this object from pixel coordinates to normalized relative coordinates [0,1].&#10;     *&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param pixelDepthScale Optional scaling factor for z-coordinate conversion&#10;     * @return NormalizedObject with coordinates in [0,1] range&#10;     */&#10;    fun toNormalized(&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        pixelDepthScale: Float = imageWidth.toFloat()&#10;    ): NormalizedObject {&#10;        // Convert bounding box coordinates&#10;        val normalizedBounding = RectF(&#10;            this.bounding.left / imageWidth,&#10;            this.bounding.top / imageHeight,&#10;            this.bounding.right / imageWidth,&#10;            this.bounding.bottom / imageHeight&#10;        )&#10;&#10;        // Convert landmarks&#10;        val normalizedLandmarks = this.landmarks.map { landmark -&gt;&#10;            landmark.toNormalized(imageWidth, imageHeight, pixelDepthScale)&#10;        }&#10;&#10;        // Convert nested objects recursively&#10;        val normalizedObjects = this.objects.map { nestedObj -&gt;&#10;            nestedObj.toNormalized(imageWidth, imageHeight, pixelDepthScale)&#10;        }&#10;&#10;        return NormalizedObject(&#10;            typeId = this.typeId,&#10;            trackingId = this.trackingId,&#10;            bounding = normalizedBounding,&#10;            normalizedLandmarks = normalizedLandmarks,&#10;            normalizedObjects = normalizedObjects,&#10;            params = this.params&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Validates that all coordinates in a NormalizedObject are within valid bounds [0,1].&#10;     *&#10;     * @param normalizedObj The object to validate&#10;     * @param checkZ Whether to also validate Z coordinates of landmarks&#10;     * @return True if all coordinates are valid, false otherwise&#10;     */&#10;    companion object {&#10;        fun isValidNormalized(normalizedObj: NormalizedObject, checkZ: Boolean = false): Boolean {&#10;            // Check bounding box&#10;            val boundingValid = normalizedObj.bounding.left in 0.0f..1.0f &amp;&amp;&#10;                    normalizedObj.bounding.top in 0.0f..1.0f &amp;&amp;&#10;                    normalizedObj.bounding.right in 0.0f..1.0f &amp;&amp;&#10;                    normalizedObj.bounding.bottom in 0.0f..1.0f&#10;&#10;            if (!boundingValid) return false&#10;&#10;            // Check landmarks using the correct property name&#10;            val landmarksValid = normalizedObj.normalizedLandmarks.all { landmark -&gt;&#10;                Landmark.isValidNormalized(landmark, checkZ)&#10;            }&#10;&#10;            if (!landmarksValid) return false&#10;&#10;            // Check nested objects recursively using the correct property name&#10;            val objectsValid = normalizedObj.normalizedObjects.all { obj -&gt;&#10;                isValidNormalized(obj, checkZ)&#10;            }&#10;&#10;            return objectsValid&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Extension function for NormalizedObject to convert back to pixel coordinates.&#10; */&#10;fun NormalizedObject.toPixel(&#10;    imageWidth: Int,&#10;    imageHeight: Int,&#10;    pixelDepthScale: Float = imageWidth.toFloat()&#10;): Object {&#10;    // Convert bounding box coordinates&#10;    val pixelBounding = RectF(&#10;        this.bounding.left * imageWidth,&#10;        this.bounding.top * imageHeight,&#10;        this.bounding.right * imageWidth,&#10;        this.bounding.bottom * imageHeight&#10;    )&#10;&#10;    // Convert landmarks using the correct property name&#10;    val pixelLandmarks = this.normalizedLandmarks.map { normalizedLandmark -&gt;&#10;        normalizedLandmark.toPixel(imageWidth, imageHeight, pixelDepthScale)&#10;    }&#10;&#10;    // Convert nested objects recursively using the correct property name&#10;    val pixelObjects = this.normalizedObjects.map { nestedObj -&gt;&#10;        nestedObj.toPixel(imageWidth, imageHeight, pixelDepthScale)&#10;    }&#10;&#10;    return Object(&#10;        typeId = this.typeId,&#10;        trackingId = this.trackingId,&#10;        bounding = pixelBounding,&#10;        landmarks = pixelLandmarks,&#10;        objects = pixelObjects,&#10;        params = this.params&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/Point3D.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/Point3D.kt" />
              <option name="originalContent" value="package kioskware.vision.landmarks&#10;&#10;import kioskware.vision.landmarks.common.CoordinateNormalizer&#10;&#10;data class Point3D(&#10;    val x: Float,&#10;    val y: Float,&#10;    val z: Float&#10;)&#10;&#10;/**&#10; * Extension functions for Point3D coordinate normalization.&#10; * These provide convenient methods for converting between different coordinate systems.&#10; */&#10;&#10;/**&#10; * Converts this point from pixel coordinates to normalized coordinates.&#10; *&#10; * @param imageWidth The width of the image in pixels&#10; * @param imageHeight The height of the image in pixels&#10; * @param pixelDepthScale Optional scaling factor for z-coordinate conversion&#10; * @return New Point3D in normalized coordinate system&#10; */&#10;fun Point3D.toNormalized(&#10;    imageWidth: Int,&#10;    imageHeight: Int,&#10;    pixelDepthScale: Float = imageWidth.toFloat()&#10;): Point3D = CoordinateNormalizer.pixelToNormalized(this, imageWidth, imageHeight, pixelDepthScale)&#10;&#10;/**&#10; * Converts this point from normalized coordinates to pixel coordinates.&#10; *&#10; * @param imageWidth The width of the image in pixels&#10; * @param imageHeight The height of the image in pixels&#10; * @param pixelDepthScale Optional scaling factor for z-coordinate conversion&#10; * @return New Point3D in pixel coordinate system&#10; */&#10;fun Point3D.toPixel(&#10;    imageWidth: Int,&#10;    imageHeight: Int,&#10;    pixelDepthScale: Float = imageWidth.toFloat()&#10;): Point3D = CoordinateNormalizer.normalizedToPixel(this, imageWidth, imageHeight, pixelDepthScale)&#10;&#10;/**&#10; * Converts this point from relative coordinates [0,1] to normalized coordinates.&#10; * Useful for ML Kit landmarks that come in relative coordinates.&#10; *&#10; * @param imageWidth The width of the image in pixels&#10; * @param imageHeight The height of the image in pixels&#10; * @param relativeDepthScale Optional scaling factor for z-coordinate&#10; * @return New Point3D in normalized coordinate system&#10; */&#10;fun Point3D.fromRelativeToNormalized(&#10;    imageWidth: Int,&#10;    imageHeight: Int,&#10;    relativeDepthScale: Float = 1.0f&#10;): Point3D = CoordinateNormalizer.relativeToNormalized(this, imageWidth, imageHeight, relativeDepthScale)&#10;&#10;/**&#10; * Converts this point from normalized coordinates to relative coordinates [0,1].&#10; *&#10; * @param imageWidth The width of the image in pixels&#10; * @param imageHeight The height of the image in pixels&#10; * @param relativeDepthScale Optional scaling factor for z-coordinate&#10; * @return New Point3D in relative coordinate system&#10; */&#10;fun Point3D.toRelative(&#10;    imageWidth: Int,&#10;    imageHeight: Int,&#10;    relativeDepthScale: Float = 1.0f&#10;): Point3D = CoordinateNormalizer.normalizedToRelative(this, imageWidth, imageHeight, relativeDepthScale)&#10;" />
              <option name="updatedContent" value="package kioskware.vision.landmarks&#10;&#10;data class Point3D(&#10;    val x: Float,&#10;    val y: Float,&#10;    val z: Float&#10;)&#10;&#10;/**&#10; * Extension functions for Point3D coordinate conversion.&#10; * These provide convenient methods for converting between pixel and relative coordinate systems.&#10; */&#10;&#10;/**&#10; * Converts this point from pixel coordinates to relative coordinates [0,1].&#10; *&#10; * @param imageWidth The width of the image in pixels&#10; * @param imageHeight The height of the image in pixels&#10; * @param pixelDepthScale Optional scaling factor for z-coordinate conversion. Defaults to imageWidth.&#10; * @return New Point3D in relative coordinate system where (0,0) is top-left, (1,1) is bottom-right&#10; */&#10;fun Point3D.toRelative(&#10;    imageWidth: Int,&#10;    imageHeight: Int,&#10;    pixelDepthScale: Float = imageWidth.toFloat()&#10;): Point3D {&#10;    require(imageWidth &gt; 0) { &quot;Image width must be positive&quot; }&#10;    require(imageHeight &gt; 0) { &quot;Image height must be positive&quot; }&#10;    &#10;    return Point3D(&#10;        x = this.x / imageWidth,&#10;        y = this.y / imageHeight,&#10;        z = this.z / pixelDepthScale&#10;    )&#10;}&#10;&#10;/**&#10; * Converts this point from relative coordinates [0,1] to pixel coordinates.&#10; *&#10; * @param imageWidth The width of the image in pixels&#10; * @param imageHeight The height of the image in pixels&#10; * @param pixelDepthScale Optional scaling factor for z-coordinate conversion. Defaults to imageWidth.&#10; * @return New Point3D in pixel coordinate system where (0,0) is top-left corner&#10; */&#10;fun Point3D.toPixel(&#10;    imageWidth: Int,&#10;    imageHeight: Int,&#10;    pixelDepthScale: Float = imageWidth.toFloat()&#10;): Point3D {&#10;    require(imageWidth &gt; 0) { &quot;Image width must be positive&quot; }&#10;    require(imageHeight &gt; 0) { &quot;Image height must be positive&quot; }&#10;    &#10;    return Point3D(&#10;        x = this.x * imageWidth,&#10;        y = this.y * imageHeight,&#10;        z = this.z * pixelDepthScale&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/common/CoordinateNormalizationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/common/CoordinateNormalizationExample.kt" />
              <option name="updatedContent" value="package kioskware.vision.landmarks.common&#10;&#10;import kioskware.vision.landmarks.Point3D&#10;import kioskware.vision.landmarks.toRelative&#10;import kioskware.vision.landmarks.toPixel&#10;&#10;/**&#10; * Example usage of the relative coordinate conversion utilities.&#10; * This demonstrates how to convert between pixel and relative coordinate systems&#10; * using the CoordinateNormalizer and Point3D extension functions.&#10; */&#10;object CoordinateConversionExample {&#10;&#10;    /**&#10;     * Demonstrates pixel to relative coordinate conversion.&#10;     */&#10;    fun examplePixelToRelative() {&#10;        // Image dimensions: 1920x1080 (Full HD)&#10;        val imageWidth = 1920&#10;        val imageHeight = 1080&#10;        &#10;        // Point at top-left corner in pixel coordinates&#10;        val topLeftPixel = Point3D(0f, 0f, 0f)&#10;        val topLeftRelative = topLeftPixel.toRelative(imageWidth, imageHeight)&#10;        println(&quot;Top-left pixel $topLeftPixel -&gt; relative $topLeftRelative&quot;)&#10;        // Expected: Point3D(0.0, 0.0, 0.0)&#10;        &#10;        // Point at center in pixel coordinates&#10;        val centerPixel = Point3D(960f, 540f, 0f)&#10;        val centerRelative = centerPixel.toRelative(imageWidth, imageHeight)&#10;        println(&quot;Center pixel $centerPixel -&gt; relative $centerRelative&quot;)&#10;        // Expected: Point3D(0.5, 0.5, 0.0)&#10;        &#10;        // Point at bottom-right corner in pixel coordinates&#10;        val bottomRightPixel = Point3D(1920f, 1080f, 0f)&#10;        val bottomRightRelative = bottomRightPixel.toRelative(imageWidth, imageHeight)&#10;        println(&quot;Bottom-right pixel $bottomRightPixel -&gt; relative $bottomRightRelative&quot;)&#10;        // Expected: Point3D(1.0, 1.0, 0.0)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates relative to pixel coordinate conversion.&#10;     */&#10;    fun exampleRelativeToPixel() {&#10;        val imageWidth = 1920&#10;        val imageHeight = 1080&#10;        &#10;        // Point at relative center&#10;        val centerRelative = Point3D(0.5f, 0.5f, 0f)&#10;        val centerPixel = centerRelative.toPixel(imageWidth, imageHeight)&#10;        println(&quot;Center relative $centerRelative -&gt; pixel $centerPixel&quot;)&#10;        // Expected: Point3D(960.0, 540.0, 0.0)&#10;        &#10;        // Point at relative top-left&#10;        val topLeftRelative = Point3D(0f, 0f, 0f)&#10;        val topLeftPixel = topLeftRelative.toPixel(imageWidth, imageHeight)&#10;        println(&quot;Top-left relative $topLeftRelative -&gt; pixel $topLeftPixel&quot;)&#10;        // Expected: Point3D(0.0, 0.0, 0.0)&#10;        &#10;        // Point at relative bottom-right&#10;        val bottomRightRelative = Point3D(1f, 1f, 0f)&#10;        val bottomRightPixel = bottomRightRelative.toPixel(imageWidth, imageHeight)&#10;        println(&quot;Bottom-right relative $bottomRightRelative -&gt; pixel $bottomRightPixel&quot;)&#10;        // Expected: Point3D(1920.0, 1080.0, 0.0)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates round-trip conversion accuracy.&#10;     */&#10;    fun exampleRoundTripConversion() {&#10;        val imageWidth = 1920&#10;        val imageHeight = 1080&#10;        &#10;        // Start with a pixel coordinate&#10;        val originalPixel = Point3D(800f, 300f, 100f)&#10;        &#10;        // Convert to relative and back&#10;        val relative = originalPixel.toRelative(imageWidth, imageHeight)&#10;        val backToPixel = relative.toPixel(imageWidth, imageHeight)&#10;        &#10;        println(&quot;Original pixel: $originalPixel&quot;)&#10;        println(&quot;Relative: $relative&quot;)&#10;        println(&quot;Back to pixel: $backToPixel&quot;)&#10;        &#10;        // Check if conversion is accurate (within floating point precision)&#10;        val deltaX = kotlin.math.abs(originalPixel.x - backToPixel.x)&#10;        val deltaY = kotlin.math.abs(originalPixel.y - backToPixel.y)&#10;        val deltaZ = kotlin.math.abs(originalPixel.z - backToPixel.z)&#10;        &#10;        println(&quot;Conversion accuracy - ΔX: $deltaX, ΔY: $deltaY, ΔZ: $deltaZ&quot;)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates working with ML Kit pose detection output.&#10;     * ML Kit typically provides landmarks in relative coordinates [0,1].&#10;     */&#10;    fun exampleMLKitCompatibility() {&#10;        val imageWidth = 1280&#10;        val imageHeight = 720&#10;        &#10;        // Simulated ML Kit pose landmarks (nose, left eye, right eye)&#10;        val noseLandmark = Point3D(0.5f, 0.3f, 0.1f)      // Center horizontally, upper third&#10;        val leftEyeLandmark = Point3D(0.45f, 0.25f, 0.05f) // Slightly left of center&#10;        val rightEyeLandmark = Point3D(0.55f, 0.25f, 0.05f) // Slightly right of center&#10;        &#10;        // Convert to pixel coordinates for drawing on screen&#10;        val nosePixel = noseLandmark.toPixel(imageWidth, imageHeight)&#10;        val leftEyePixel = leftEyeLandmark.toPixel(imageWidth, imageHeight)&#10;        val rightEyePixel = rightEyeLandmark.toPixel(imageWidth, imageHeight)&#10;        &#10;        println(&quot;ML Kit Landmarks to Pixel Conversion:&quot;)&#10;        println(&quot;Nose: $noseLandmark -&gt; $nosePixel&quot;)&#10;        println(&quot;Left Eye: $leftEyeLandmark -&gt; $leftEyePixel&quot;)&#10;        println(&quot;Right Eye: $rightEyeLandmark -&gt; $rightEyePixel&quot;)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates coordinate validation and clamping.&#10;     */&#10;    fun exampleValidationAndClamping() {&#10;        // Some coordinates that might be outside valid range&#10;        val validPoint = Point3D(0.5f, 0.7f, 0.2f)&#10;        val invalidPoint = Point3D(1.2f, -0.1f, 0.8f)&#10;        &#10;        println(&quot;Valid point: $validPoint - Is valid: ${CoordinateNormalizer.isValidRelativePoint(validPoint)}&quot;)&#10;        println(&quot;Invalid point: $invalidPoint - Is valid: ${CoordinateNormalizer.isValidRelativePoint(invalidPoint)}&quot;)&#10;        &#10;        // Clamp invalid coordinates to valid range&#10;        val clampedPoint = CoordinateNormalizer.clampToRelativeBounds(invalidPoint)&#10;        println(&quot;Clamped point: $clampedPoint - Is valid: ${CoordinateNormalizer.isValidRelativePoint(clampedPoint)}&quot;)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates depth (Z-coordinate) handling with different scaling.&#10;     */&#10;    fun exampleDepthHandling() {&#10;        val imageWidth = 1920&#10;        val imageHeight = 1080&#10;        &#10;        // Point with depth information (e.g., from pose detection)&#10;        val pointWithDepth = Point3D(960f, 540f, 50f) // 50 pixels &quot;into&quot; the scene&#10;        &#10;        // Convert using default depth scaling (based on image width)&#10;        val relativeDefault = pointWithDepth.toRelative(imageWidth, imageHeight)&#10;        println(&quot;Default depth scaling: $pointWithDepth -&gt; $relativeDefault&quot;)&#10;        &#10;        // Convert using custom depth scaling&#10;        val customDepthScale = 100f // Custom scale for depth&#10;        val relativeCustom = pointWithDepth.toRelative(imageWidth, imageHeight, customDepthScale)&#10;        println(&quot;Custom depth scaling: $pointWithDepth -&gt; $relativeCustom&quot;)&#10;        &#10;        // The Z-coordinate scaling allows for flexible depth representation&#10;        // while maintaining consistency across different image sizes&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/common/CoordinateNormalizer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/common/CoordinateNormalizer.kt" />
              <option name="originalContent" value="package kioskware.vision.landmarks.common&#10;&#10;import kioskware.vision.landmarks.Point3D&#10;&#10;/**&#10; * Utility class for converting between pixel coordinates and normalized coordinates.&#10; *&#10; * This normalizer implements the coordinate system defined by the [Normalized] interface,&#10; * providing conversion methods for Point3D objects based on image resolution.&#10; *&#10; * ## Coordinate System Overview&#10; * - **Origin:** Image center at [0, 0]&#10; * - **X-axis:** [-1, 1] spanning full image width&#10; * - **Y-axis:** [-aspectRatio, aspectRatio] where aspectRatio = height/width&#10; * - **Z-axis:** Same scale as width, typically [-1, 1] for pose detection&#10; *&#10; * @see Normalized&#10; */&#10;object CoordinateNormalizer {&#10;&#10;    /**&#10;     * Converts pixel coordinates to normalized coordinates.&#10;     *&#10;     * @param pixelPoint The point in pixel coordinates where (0,0) is top-left corner&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param pixelDepthScale Optional scaling factor for z-coordinate conversion from pixel space.&#10;     *                       Defaults to imageWidth for proportional scaling.&#10;     * @return Point3D in normalized coordinate system&#10;     */&#10;    fun pixelToNormalized(&#10;        pixelPoint: Point3D,&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        pixelDepthScale: Float = imageWidth.toFloat()&#10;    ): Point3D {&#10;        require(imageWidth &gt; 0) { &quot;Image width must be positive&quot; }&#10;        require(imageHeight &gt; 0) { &quot;Image height must be positive&quot; }&#10;&#10;        val aspectRatio = imageHeight.toFloat() / imageWidth.toFloat()&#10;&#10;        // Convert from pixel coordinates (top-left origin) to normalized coordinates (center origin)&#10;        val normalizedX = (pixelPoint.x / imageWidth) * Normalized.NORMALIZED_WIDTH - 1.0f&#10;        val normalizedY = (1.0f - pixelPoint.y / imageHeight) * (2.0f * aspectRatio) - aspectRatio&#10;        val normalizedZ = (pixelPoint.z / pixelDepthScale) * Normalized.Z_SCALE_FACTOR&#10;&#10;        return Point3D(normalizedX, normalizedY, normalizedZ)&#10;    }&#10;&#10;    /**&#10;     * Converts normalized coordinates to pixel coordinates.&#10;     *&#10;     * @param normalizedPoint The point in normalized coordinate system&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param pixelDepthScale Optional scaling factor for z-coordinate conversion to pixel space.&#10;     *                       Defaults to imageWidth for proportional scaling.&#10;     * @return Point3D in pixel coordinate system where (0,0) is top-left corner&#10;     */&#10;    fun normalizedToPixel(&#10;        normalizedPoint: Point3D,&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        pixelDepthScale: Float = imageWidth.toFloat()&#10;    ): Point3D {&#10;        require(imageWidth &gt; 0) { &quot;Image width must be positive&quot; }&#10;        require(imageHeight &gt; 0) { &quot;Image height must be positive&quot; }&#10;&#10;        val aspectRatio = imageHeight.toFloat() / imageWidth.toFloat()&#10;&#10;        // Convert from normalized coordinates (center origin) to pixel coordinates (top-left origin)&#10;        val pixelX = (normalizedPoint.x + 1.0f) * imageWidth / Normalized.NORMALIZED_WIDTH&#10;        val pixelY = (aspectRatio - normalizedPoint.y) * imageHeight / (2.0f * aspectRatio)&#10;        val pixelZ = (normalizedPoint.z / Normalized.Z_SCALE_FACTOR) * pixelDepthScale&#10;&#10;        return Point3D(pixelX, pixelY, pixelZ)&#10;    }&#10;&#10;    /**&#10;     * Normalizes a point that is already in relative coordinates [0,1] to the normalized system.&#10;     * This is useful when working with ML Kit landmarks that come in relative coordinates.&#10;     *&#10;     * @param relativePoint The point in relative coordinates where (0,0) is top-left, (1,1) is bottom-right&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param relativeDepthScale Optional scaling factor for z-coordinate in relative space.&#10;     *                          Defaults to 1.0f assuming z is already in relative scale.&#10;     * @return Point3D in normalized coordinate system&#10;     */&#10;    fun relativeToNormalized(&#10;        relativePoint: Point3D,&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        relativeDepthScale: Float = 1.0f&#10;    ): Point3D {&#10;        require(imageWidth &gt; 0) { &quot;Image width must be positive&quot; }&#10;        require(imageHeight &gt; 0) { &quot;Image height must be positive&quot; }&#10;&#10;        val aspectRatio = imageHeight.toFloat() / imageWidth.toFloat()&#10;&#10;        // Convert from relative coordinates [0,1] to normalized coordinates&#10;        val normalizedX = relativePoint.x * Normalized.NORMALIZED_WIDTH - 1.0f&#10;        val normalizedY = (1.0f - relativePoint.y) * (2.0f * aspectRatio) - aspectRatio&#10;        val normalizedZ = (relativePoint.z / relativeDepthScale) * Normalized.Z_SCALE_FACTOR&#10;&#10;        return Point3D(normalizedX, normalizedY, normalizedZ)&#10;    }&#10;&#10;    /**&#10;     * Converts normalized coordinates to relative coordinates [0,1].&#10;     *&#10;     * @param normalizedPoint The point in normalized coordinate system&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param relativeDepthScale Optional scaling factor for z-coordinate in relative space.&#10;     *                          Defaults to 1.0f for direct relative scaling.&#10;     * @return Point3D in relative coordinate system where (0,0) is top-left, (1,1) is bottom-right&#10;     */&#10;    fun normalizedToRelative(&#10;        normalizedPoint: Point3D,&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        relativeDepthScale: Float = 1.0f&#10;    ): Point3D {&#10;        require(imageWidth &gt; 0) { &quot;Image width must be positive&quot; }&#10;        require(imageHeight &gt; 0) { &quot;Image height must be positive&quot; }&#10;&#10;        val aspectRatio = imageHeight.toFloat() / imageWidth.toFloat()&#10;&#10;        // Convert from normalized coordinates to relative coordinates [0,1]&#10;        val relativeX = (normalizedPoint.x + 1.0f) / Normalized.NORMALIZED_WIDTH&#10;        val relativeY = 1.0f - (normalizedPoint.y + aspectRatio) / (2.0f * aspectRatio)&#10;        val relativeZ = (normalizedPoint.z / Normalized.Z_SCALE_FACTOR) * relativeDepthScale&#10;&#10;        return Point3D(relativeX, relativeY, relativeZ)&#10;    }&#10;&#10;    /**&#10;     * Calculates the aspect ratio for given image dimensions.&#10;     *&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @return The aspect ratio (height/width)&#10;     */&#10;    fun calculateAspectRatio(imageWidth: Int, imageHeight: Int): Float {&#10;        require(imageWidth &gt; 0) { &quot;Image width must be positive&quot; }&#10;        require(imageHeight &gt; 0) { &quot;Image height must be positive&quot; }&#10;        return imageHeight.toFloat() / imageWidth.toFloat()&#10;    }&#10;&#10;    /**&#10;     * Gets the normalized coordinate bounds for given image dimensions.&#10;     *&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @return Triple containing (xRange, yRange, aspectRatio) where ranges are Pair(min, max)&#10;     */&#10;    fun getNormalizedBounds(imageWidth: Int, imageHeight: Int): Triple&lt;Pair&lt;Float, Float&gt;, Pair&lt;Float, Float&gt;, Float&gt; {&#10;        val aspectRatio = calculateAspectRatio(imageWidth, imageHeight)&#10;        val xRange = Pair(-1.0f, 1.0f)&#10;        val yRange = Pair(-aspectRatio, aspectRatio)&#10;        return Triple(xRange, yRange, aspectRatio)&#10;    }&#10;    &#10;}&#10;" />
              <option name="updatedContent" value="package kioskware.vision.landmarks.common&#10;&#10;import kioskware.vision.landmarks.Point3D&#10;&#10;/**&#10; * Utility class for converting between pixel coordinates and relative coordinates.&#10; *&#10; * This utility provides conversion methods for Point3D objects using a relative coordinate system&#10; * that is compatible with ML Kit and other computer vision frameworks.&#10; *&#10; * ## Coordinate System Overview&#10; * - **Relative coordinates:** [0,1] range for both X and Y axes&#10; * - **Origin:** Top-left corner at [0, 0]&#10; * - **X-axis:** [0, 1] where 0 = left edge, 1 = right edge&#10; * - **Y-axis:** [0, 1] where 0 = top edge, 1 = bottom edge&#10; * - **Z-axis:** Scaled proportionally, typically [0, 1] for depth measurements&#10; */&#10;object CoordinateNormalizer {&#10;&#10;    /**&#10;     * Converts pixel coordinates to relative coordinates [0,1].&#10;     *&#10;     * @param pixelPoint The point in pixel coordinates where (0,0) is top-left corner&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param pixelDepthScale Optional scaling factor for z-coordinate conversion from pixel space.&#10;     *                       Defaults to imageWidth for proportional scaling.&#10;     * @return Point3D in relative coordinate system [0,1]&#10;     */&#10;    fun pixelToRelative(&#10;        pixelPoint: Point3D,&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        pixelDepthScale: Float = imageWidth.toFloat()&#10;    ): Point3D {&#10;        require(imageWidth &gt; 0) { &quot;Image width must be positive&quot; }&#10;        require(imageHeight &gt; 0) { &quot;Image height must be positive&quot; }&#10;&#10;        return Point3D(&#10;            x = pixelPoint.x / imageWidth,&#10;            y = pixelPoint.y / imageHeight,&#10;            z = pixelPoint.z / pixelDepthScale&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Converts relative coordinates [0,1] to pixel coordinates.&#10;     *&#10;     * @param relativePoint The point in relative coordinate system [0,1]&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param pixelDepthScale Optional scaling factor for z-coordinate conversion to pixel space.&#10;     *                       Defaults to imageWidth for proportional scaling.&#10;     * @return Point3D in pixel coordinate system where (0,0) is top-left corner&#10;     */&#10;    fun relativeToPixel(&#10;        relativePoint: Point3D,&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        pixelDepthScale: Float = imageWidth.toFloat()&#10;    ): Point3D {&#10;        require(imageWidth &gt; 0) { &quot;Image width must be positive&quot; }&#10;        require(imageHeight &gt; 0) { &quot;Image height must be positive&quot; }&#10;&#10;        return Point3D(&#10;            x = relativePoint.x * imageWidth,&#10;            y = relativePoint.y * imageHeight,&#10;            z = relativePoint.z * pixelDepthScale&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Calculates the aspect ratio for given image dimensions.&#10;     *&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @return The aspect ratio (height/width)&#10;     */&#10;    fun calculateAspectRatio(imageWidth: Int, imageHeight: Int): Float {&#10;        require(imageWidth &gt; 0) { &quot;Image width must be positive&quot; }&#10;        require(imageHeight &gt; 0) { &quot;Image height must be positive&quot; }&#10;        return imageHeight.toFloat() / imageWidth.toFloat()&#10;    }&#10;&#10;    /**&#10;     * Validates that a point is within relative coordinate bounds [0,1].&#10;     *&#10;     * @param point The point to validate&#10;     * @param checkZ Whether to also validate the Z coordinate (default: false)&#10;     * @return True if the point is within bounds, false otherwise&#10;     */&#10;    fun isValidRelativePoint(point: Point3D, checkZ: Boolean = false): Boolean {&#10;        val validXY = point.x in 0.0f..1.0f &amp;&amp; point.y in 0.0f..1.0f&#10;        return if (checkZ) {&#10;            validXY &amp;&amp; point.z in 0.0f..1.0f&#10;        } else {&#10;            validXY&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clamps a point to relative coordinate bounds [0,1].&#10;     *&#10;     * @param point The point to clamp&#10;     * @param clampZ Whether to also clamp the Z coordinate (default: false)&#10;     * @return New Point3D with coordinates clamped to [0,1] range&#10;     */&#10;    fun clampToRelativeBounds(point: Point3D, clampZ: Boolean = false): Point3D {&#10;        val clampedX = point.x.coerceIn(0.0f, 1.0f)&#10;        val clampedY = point.y.coerceIn(0.0f, 1.0f)&#10;        val clampedZ = if (clampZ) point.z.coerceIn(0.0f, 1.0f) else point.z&#10;        &#10;        return Point3D(clampedX, clampedY, clampedZ)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/common/NormalizationConversionExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/common/NormalizationConversionExample.kt" />
              <option name="originalContent" value="package kioskware.vision.landmarks.common&#10;&#10;import android.graphics.RectF&#10;import kioskware.vision.landmarks.*&#10;&#10;/**&#10; * Examples demonstrating how to convert between regular and normalized Landmark/Object instances.&#10; * This shows practical usage of the NormalizationConverter utility and extension functions.&#10; */&#10;object NormalizationConversionExample {&#10;&#10;    /**&#10;     * Demonstrates converting a Landmark from pixel to normalized coordinates.&#10;     */&#10;    fun exampleLandmarkToNormalized() {&#10;        val imageWidth = 1920&#10;        val imageHeight = 1080&#10;        &#10;        // Create a landmark in pixel coordinates (e.g., from custom detection)&#10;        val pixelLandmark = Landmark(&#10;            typeId = &quot;nose&quot;,&#10;            location = Point3D(960f, 324f, 50f), // Center-x, upper portion, some depth&#10;            score = 0.95f&#10;        )&#10;        &#10;        // Convert to normalized coordinates using extension function&#10;        val normalizedLandmark = pixelLandmark.toNormalized(imageWidth, imageHeight)&#10;        &#10;        println(&quot;Pixel Landmark: ${pixelLandmark.location}&quot;)&#10;        println(&quot;Normalized Landmark: ${normalizedLandmark.location}&quot;)&#10;        // Expected: Point3D(0.5, 0.3, ~0.026)&#10;        &#10;        // Convert back to verify accuracy&#10;        val backToPixel = normalizedLandmark.toPixel(imageWidth, imageHeight)&#10;        println(&quot;Back to Pixel: ${backToPixel.location}&quot;)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates converting an Object from pixel to normalized coordinates.&#10;     */&#10;    fun exampleObjectToNormalized() {&#10;        val imageWidth = 1280&#10;        val imageHeight = 720&#10;        &#10;        // Create landmarks for a face detection&#10;        val noseLandmark = Landmark(&quot;nose&quot;, Point3D(640f, 300f, 10f), 0.98f)&#10;        val leftEyeLandmark = Landmark(&quot;left_eye&quot;, Point3D(600f, 280f, 8f), 0.95f)&#10;        val rightEyeLandmark = Landmark(&quot;right_eye&quot;, Point3D(680f, 280f, 8f), 0.96f)&#10;        &#10;        // Create an object representing a detected face&#10;        val faceObject = Object(&#10;            typeId = &quot;face&quot;,&#10;            trackingId = &quot;face_001&quot;,&#10;            bounding = RectF(550f, 250f, 730f, 400f), // Bounding box around face&#10;            landmarks = listOf(noseLandmark, leftEyeLandmark, rightEyeLandmark)&#10;        )&#10;        &#10;        // Convert to normalized coordinates&#10;        val normalizedFace = faceObject.toNormalized(imageWidth, imageHeight)&#10;        &#10;        println(&quot;Original Object Bounding: ${faceObject.bounding}&quot;)&#10;        println(&quot;Normalized Object Bounding: ${normalizedFace.bounding}&quot;)&#10;        // Expected bounding: left=0.43, top=0.35, right=0.57, bottom=0.56&#10;        &#10;        println(&quot;Original landmarks count: ${faceObject.landmarks.size}&quot;)&#10;        println(&quot;Normalized landmarks count: ${normalizedFace.landmarks.size}&quot;)&#10;        &#10;        // Show landmark conversion&#10;        normalizedFace.landmarks.forEachIndexed { index, landmark -&gt;&#10;            println(&quot;Landmark ${landmark.typeId}: ${landmark.location}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Demonstrates working with ML Kit output that's already in relative coordinates.&#10;     */&#10;    fun exampleMLKitIntegration() {&#10;        val imageWidth = 1920&#10;        val imageHeight = 1080&#10;        &#10;        // Simulate ML Kit pose detection output (already in relative coordinates)&#10;        val mlKitNoseLandmark = NormalizedLandmark(&#10;            typeId = &quot;nose&quot;,&#10;            location = Point3D(0.5f, 0.3f, 0.1f),&#10;            score = 0.97f&#10;        )&#10;        &#10;        val mlKitLeftShoulder = NormalizedLandmark(&#10;            typeId = &quot;left_shoulder&quot;, &#10;            location = Point3D(0.4f, 0.6f, 0.05f),&#10;            score = 0.89f&#10;        )&#10;        &#10;        // Create a normalized pose object&#10;        val normalizedPose = NormalizedObject(&#10;            typeId = &quot;human_pose&quot;,&#10;            trackingId = &quot;person_001&quot;,&#10;            bounding = RectF(0.25f, 0.2f, 0.75f, 0.9f), // Person bounding box&#10;            landmarks = listOf(mlKitNoseLandmark, mlKitLeftShoulder)&#10;        )&#10;        &#10;        // Convert to pixel coordinates for drawing on screen&#10;        val pixelPose = normalizedPose.toPixel(imageWidth, imageHeight)&#10;        &#10;        println(&quot;ML Kit Integration Example:&quot;)&#10;        println(&quot;Normalized nose: ${mlKitNoseLandmark.location}&quot;)&#10;        println(&quot;Pixel nose: ${pixelPose.landmarks.find { it.typeId == &quot;nose&quot; }?.location}&quot;)&#10;        &#10;        // Validate the normalized object&#10;        val isValid = NormalizationConverter.isValidNormalizedObject(normalizedPose)&#10;        println(&quot;Normalized object is valid: $isValid&quot;)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates nested object conversion.&#10;     */&#10;    fun exampleNestedObjectConversion() {&#10;        val imageWidth = 1280&#10;        val imageHeight = 720&#10;        &#10;        // Create a hand object with finger landmarks&#10;        val thumbTip = Landmark(&quot;thumb_tip&quot;, Point3D(400f, 300f, 5f), 0.92f)&#10;        val indexTip = Landmark(&quot;index_tip&quot;, Point3D(420f, 280f, 8f), 0.94f)&#10;        &#10;        val handObject = Object(&#10;            typeId = &quot;hand&quot;,&#10;            trackingId = &quot;left_hand&quot;,&#10;            bounding = RectF(350f, 250f, 450f, 350f),&#10;            landmarks = listOf(thumbTip, indexTip)&#10;        )&#10;        &#10;        // Create a person object containing the hand&#10;        val personObject = Object(&#10;            typeId = &quot;person&quot;,&#10;            trackingId = &quot;person_001&quot;, &#10;            bounding = RectF(200f, 100f, 800f, 600f),&#10;            objects = listOf(handObject) // Nested hand object&#10;        )&#10;        &#10;        // Convert the entire hierarchy to normalized coordinates&#10;        val normalizedPerson = personObject.toNormalized(imageWidth, imageHeight)&#10;        &#10;        println(&quot;Nested Object Conversion:&quot;)&#10;        println(&quot;Original person bounding: ${personObject.bounding}&quot;)&#10;        println(&quot;Normalized person bounding: ${normalizedPerson.bounding}&quot;)&#10;        &#10;        // Access nested hand object&#10;        val normalizedHand = normalizedPerson.objects.first()&#10;        println(&quot;Original hand bounding: ${handObject.bounding}&quot;)&#10;        println(&quot;Normalized hand bounding: ${normalizedHand.bounding}&quot;)&#10;        &#10;        // Verify nested landmark conversion&#10;        val originalThumb = handObject.landmarks.find { it.typeId == &quot;thumb_tip&quot; }&#10;        val normalizedThumb = normalizedHand.landmarks.find { it.typeId == &quot;thumb_tip&quot; }&#10;        println(&quot;Original thumb: ${originalThumb?.location}&quot;)&#10;        println(&quot;Normalized thumb: ${normalizedThumb?.location}&quot;)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates validation and error handling.&#10;     */&#10;    fun exampleValidationAndErrorHandling() {&#10;        // Create a landmark with invalid coordinates (outside [0,1] range)&#10;        val invalidNormalizedLandmark = NormalizedLandmark(&#10;            typeId = &quot;invalid&quot;,&#10;            location = Point3D(1.5f, -0.2f, 0.5f), // Invalid x and y coordinates&#10;            score = 0.8f&#10;        )&#10;        &#10;        // Validate the landmark&#10;        val isValid = NormalizationConverter.isValidNormalizedLandmark(invalidNormalizedLandmark)&#10;        println(&quot;Invalid landmark validation result: $isValid&quot;)&#10;        &#10;        // Clamp the coordinates to valid range&#10;        val clampedLocation = CoordinateNormalizer.clampToRelativeBounds(invalidNormalizedLandmark.location)&#10;        val correctedLandmark = NormalizedLandmark(&#10;            typeId = invalidNormalizedLandmark.typeId,&#10;            location = clampedLocation,&#10;            score = invalidNormalizedLandmark.score&#10;        )&#10;        &#10;        println(&quot;Original invalid location: ${invalidNormalizedLandmark.location}&quot;)&#10;        println(&quot;Clamped valid location: ${correctedLandmark.location}&quot;)&#10;        &#10;        // Verify the corrected landmark is now valid&#10;        val isCorrectedValid = NormalizationConverter.isValidNormalizedLandmark(correctedLandmark)&#10;        println(&quot;Corrected landmark validation result: $isCorrectedValid&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package kioskware.vision.landmarks.common&#10;&#10;import android.graphics.RectF&#10;import kioskware.vision.landmarks.*&#10;&#10;/**&#10; * Examples demonstrating how to convert between regular and normalized Landmark/Object instances.&#10; * This shows practical usage of the normalization methods now integrated into the Landmark and Object classes.&#10; */&#10;object NormalizationConversionExample {&#10;&#10;    /**&#10;     * Demonstrates converting a Landmark from pixel to normalized coordinates.&#10;     */&#10;    fun exampleLandmarkToNormalized() {&#10;        val imageWidth = 1920&#10;        val imageHeight = 1080&#10;        &#10;        // Create a landmark in pixel coordinates (e.g., from custom detection)&#10;        val pixelLandmark = Landmark(&#10;            typeId = &quot;nose&quot;,&#10;            location = Point3D(960f, 324f, 50f), // Center-x, upper portion, some depth&#10;            score = 0.95f&#10;        )&#10;        &#10;        // Convert to normalized coordinates using instance method&#10;        val normalizedLandmark = pixelLandmark.toNormalized(imageWidth, imageHeight)&#10;        &#10;        println(&quot;Pixel Landmark: ${pixelLandmark.location}&quot;)&#10;        println(&quot;Normalized Landmark: ${normalizedLandmark.location}&quot;)&#10;        // Expected: Point3D(0.5, 0.3, ~0.026)&#10;        &#10;        // Convert back to verify accuracy using extension function&#10;        val backToPixel = normalizedLandmark.toPixel(imageWidth, imageHeight)&#10;        println(&quot;Back to Pixel: ${backToPixel.location}&quot;)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates converting an Object from pixel to normalized coordinates.&#10;     */&#10;    fun exampleObjectToNormalized() {&#10;        val imageWidth = 1280&#10;        val imageHeight = 720&#10;        &#10;        // Create landmarks for a face detection&#10;        val noseLandmark = Landmark(&quot;nose&quot;, Point3D(640f, 300f, 10f), 0.98f)&#10;        val leftEyeLandmark = Landmark(&quot;left_eye&quot;, Point3D(600f, 280f, 8f), 0.95f)&#10;        val rightEyeLandmark = Landmark(&quot;right_eye&quot;, Point3D(680f, 280f, 8f), 0.96f)&#10;        &#10;        // Create an object representing a detected face&#10;        val faceObject = Object(&#10;            typeId = &quot;face&quot;,&#10;            trackingId = &quot;face_001&quot;,&#10;            bounding = RectF(550f, 250f, 730f, 400f), // Bounding box around face&#10;            landmarks = listOf(noseLandmark, leftEyeLandmark, rightEyeLandmark)&#10;        )&#10;        &#10;        // Convert to normalized coordinates using instance method&#10;        val normalizedFace = faceObject.toNormalized(imageWidth, imageHeight)&#10;        &#10;        println(&quot;Original Object Bounding: ${faceObject.bounding}&quot;)&#10;        println(&quot;Normalized Object Bounding: ${normalizedFace.bounding}&quot;)&#10;        // Expected bounding: left=0.43, top=0.35, right=0.57, bottom=0.56&#10;        &#10;        println(&quot;Original landmarks count: ${faceObject.landmarks.size}&quot;)&#10;        println(&quot;Normalized landmarks count: ${normalizedFace.landmarks.size}&quot;)&#10;        &#10;        // Show landmark conversion&#10;        normalizedFace.landmarks.forEachIndexed { index, landmark -&gt;&#10;            println(&quot;Landmark ${landmark.typeId}: ${landmark.location}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Demonstrates working with ML Kit output that's already in relative coordinates.&#10;     */&#10;    fun exampleMLKitIntegration() {&#10;        val imageWidth = 1920&#10;        val imageHeight = 1080&#10;        &#10;        // Simulate ML Kit pose detection output (already in relative coordinates)&#10;        val mlKitNoseLandmark = NormalizedLandmark(&#10;            typeId = &quot;nose&quot;,&#10;            location = Point3D(0.5f, 0.3f, 0.1f),&#10;            score = 0.97f&#10;        )&#10;        &#10;        val mlKitLeftShoulder = NormalizedLandmark(&#10;            typeId = &quot;left_shoulder&quot;, &#10;            location = Point3D(0.4f, 0.6f, 0.05f),&#10;            score = 0.89f&#10;        )&#10;        &#10;        // Create a normalized pose object&#10;        val normalizedPose = NormalizedObject(&#10;            typeId = &quot;human_pose&quot;,&#10;            trackingId = &quot;person_001&quot;,&#10;            bounding = RectF(0.25f, 0.2f, 0.75f, 0.9f), // Person bounding box&#10;            landmarks = listOf(mlKitNoseLandmark, mlKitLeftShoulder)&#10;        )&#10;        &#10;        // Convert to pixel coordinates for drawing on screen using extension function&#10;        val pixelPose = normalizedPose.toPixel(imageWidth, imageHeight)&#10;        &#10;        println(&quot;ML Kit Integration Example:&quot;)&#10;        println(&quot;Normalized nose: ${mlKitNoseLandmark.location}&quot;)&#10;        println(&quot;Pixel nose: ${pixelPose.landmarks.find { it.typeId == &quot;nose&quot; }?.location}&quot;)&#10;        &#10;        // Validate the normalized object using companion object method&#10;        val isValid = Object.isValidNormalized(normalizedPose)&#10;        println(&quot;Normalized object is valid: $isValid&quot;)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates nested object conversion.&#10;     */&#10;    fun exampleNestedObjectConversion() {&#10;        val imageWidth = 1280&#10;        val imageHeight = 720&#10;        &#10;        // Create a hand object with finger landmarks&#10;        val thumbTip = Landmark(&quot;thumb_tip&quot;, Point3D(400f, 300f, 5f), 0.92f)&#10;        val indexTip = Landmark(&quot;index_tip&quot;, Point3D(420f, 280f, 8f), 0.94f)&#10;        &#10;        val handObject = Object(&#10;            typeId = &quot;hand&quot;,&#10;            trackingId = &quot;left_hand&quot;,&#10;            bounding = RectF(350f, 250f, 450f, 350f),&#10;            landmarks = listOf(thumbTip, indexTip)&#10;        )&#10;        &#10;        // Create a person object containing the hand&#10;        val personObject = Object(&#10;            typeId = &quot;person&quot;,&#10;            trackingId = &quot;person_001&quot;, &#10;            bounding = RectF(200f, 100f, 800f, 600f),&#10;            objects = listOf(handObject) // Nested hand object&#10;        )&#10;        &#10;        // Convert the entire hierarchy to normalized coordinates using instance method&#10;        val normalizedPerson = personObject.toNormalized(imageWidth, imageHeight)&#10;        &#10;        println(&quot;Nested Object Conversion:&quot;)&#10;        println(&quot;Original person bounding: ${personObject.bounding}&quot;)&#10;        println(&quot;Normalized person bounding: ${normalizedPerson.bounding}&quot;)&#10;        &#10;        // Access nested hand object&#10;        val normalizedHand = normalizedPerson.objects.first()&#10;        println(&quot;Original hand bounding: ${handObject.bounding}&quot;)&#10;        println(&quot;Normalized hand bounding: ${normalizedHand.bounding}&quot;)&#10;        &#10;        // Verify nested landmark conversion&#10;        val originalThumb = handObject.landmarks.find { it.typeId == &quot;thumb_tip&quot; }&#10;        val normalizedThumb = normalizedHand.landmarks.find { it.typeId == &quot;thumb_tip&quot; }&#10;        println(&quot;Original thumb: ${originalThumb?.location}&quot;)&#10;        println(&quot;Normalized thumb: ${normalizedThumb?.location}&quot;)&#10;    }&#10;&#10;    /**&#10;     * Demonstrates validation and error handling.&#10;     */&#10;    fun exampleValidationAndErrorHandling() {&#10;        // Create a landmark with invalid coordinates (outside [0,1] range)&#10;        val invalidNormalizedLandmark = NormalizedLandmark(&#10;            typeId = &quot;invalid&quot;,&#10;            location = Point3D(1.5f, -0.2f, 0.5f), // Invalid x and y coordinates&#10;            score = 0.8f&#10;        )&#10;        &#10;        // Validate the landmark using companion object method&#10;        val isValid = Landmark.isValidNormalized(invalidNormalizedLandmark)&#10;        println(&quot;Invalid landmark validation result: $isValid&quot;)&#10;        &#10;        // Clamp the coordinates to valid range&#10;        val clampedLocation = CoordinateNormalizer.clampToRelativeBounds(invalidNormalizedLandmark.location)&#10;        val correctedLandmark = NormalizedLandmark(&#10;            typeId = invalidNormalizedLandmark.typeId,&#10;            location = clampedLocation,&#10;            score = invalidNormalizedLandmark.score&#10;        )&#10;        &#10;        println(&quot;Original invalid location: ${invalidNormalizedLandmark.location}&quot;)&#10;        println(&quot;Clamped valid location: ${correctedLandmark.location}&quot;)&#10;        &#10;        // Verify the corrected landmark is now valid&#10;        val isCorrectedValid = Landmark.isValidNormalized(correctedLandmark)&#10;        println(&quot;Corrected landmark validation result: $isCorrectedValid&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/common/NormalizationConverter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/common/NormalizationConverter.kt" />
              <option name="originalContent" value="package kioskware.vision.landmarks.common&#10;&#10;import android.graphics.RectF&#10;import kioskware.vision.landmarks.*&#10;&#10;/**&#10; * Utility object for converting between regular and normalized coordinate systems&#10; * for Landmark and Object instances.&#10; */&#10;object NormalizationConverter {&#10;&#10;    /**&#10;     * Converts a Landmark with pixel coordinates to a NormalizedLandmark with relative coordinates.&#10;     *&#10;     * @param landmark The landmark in pixel coordinates&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param pixelDepthScale Optional scaling factor for z-coordinate conversion&#10;     * @return NormalizedLandmark with coordinates in [0,1] range&#10;     */&#10;    fun toNormalized(&#10;        landmark: Landmark,&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        pixelDepthScale: Float = imageWidth.toFloat()&#10;    ): NormalizedLandmark {&#10;        val normalizedLocation = landmark.location.toRelative(imageWidth, imageHeight, pixelDepthScale)&#10;        return NormalizedLandmark(landmark.typeId, normalizedLocation, landmark.score)&#10;    }&#10;&#10;    /**&#10;     * Converts a NormalizedLandmark with relative coordinates to a Landmark with pixel coordinates.&#10;     *&#10;     * @param normalizedLandmark The landmark in relative coordinates [0,1]&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param pixelDepthScale Optional scaling factor for z-coordinate conversion&#10;     * @return Landmark with coordinates in pixel space&#10;     */&#10;    fun toPixel(&#10;        normalizedLandmark: NormalizedLandmark,&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        pixelDepthScale: Float = imageWidth.toFloat()&#10;    ): Landmark {&#10;        val pixelLocation = normalizedLandmark.location.toPixel(imageWidth, imageHeight, pixelDepthScale)&#10;        return Landmark(normalizedLandmark.typeId, pixelLocation, normalizedLandmark.score)&#10;    }&#10;&#10;    /**&#10;     * Converts an Object with pixel coordinates to a NormalizedObject with relative coordinates.&#10;     *&#10;     * @param obj The object in pixel coordinates&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param pixelDepthScale Optional scaling factor for z-coordinate conversion&#10;     * @return NormalizedObject with coordinates in [0,1] range&#10;     */&#10;    fun toNormalized(&#10;        obj: Object,&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        pixelDepthScale: Float = imageWidth.toFloat()&#10;    ): NormalizedObject {&#10;        // Convert bounding box coordinates&#10;        val normalizedBounding = RectF(&#10;            obj.bounding.left / imageWidth,&#10;            obj.bounding.top / imageHeight,&#10;            obj.bounding.right / imageWidth,&#10;            obj.bounding.bottom / imageHeight&#10;        )&#10;&#10;        // Convert landmarks&#10;        val normalizedLandmarks = obj.landmarks.map { landmark -&gt;&#10;            toNormalized(landmark, imageWidth, imageHeight, pixelDepthScale)&#10;        }&#10;&#10;        // Convert nested objects recursively&#10;        val normalizedObjects = obj.objects.map { nestedObj -&gt;&#10;            toNormalized(nestedObj, imageWidth, imageHeight, pixelDepthScale)&#10;        }&#10;&#10;        return NormalizedObject(&#10;            typeId = obj.typeId,&#10;            trackingId = obj.trackingId,&#10;            bounding = normalizedBounding,&#10;            landmarks = normalizedLandmarks,&#10;            objects = normalizedObjects,&#10;            params = obj.params&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Converts a NormalizedObject with relative coordinates to an Object with pixel coordinates.&#10;     *&#10;     * @param normalizedObj The object in relative coordinates [0,1]&#10;     * @param imageWidth The width of the image in pixels&#10;     * @param imageHeight The height of the image in pixels&#10;     * @param pixelDepthScale Optional scaling factor for z-coordinate conversion&#10;     * @return Object with coordinates in pixel space&#10;     */&#10;    fun toPixel(&#10;        normalizedObj: NormalizedObject,&#10;        imageWidth: Int,&#10;        imageHeight: Int,&#10;        pixelDepthScale: Float = imageWidth.toFloat()&#10;    ): Object {&#10;        // Convert bounding box coordinates&#10;        val pixelBounding = RectF(&#10;            normalizedObj.bounding.left * imageWidth,&#10;            normalizedObj.bounding.top * imageHeight,&#10;            normalizedObj.bounding.right * imageWidth,&#10;            normalizedObj.bounding.bottom * imageHeight&#10;        )&#10;&#10;        // Convert landmarks with explicit type casting&#10;        val pixelLandmarks = normalizedObj.landmarks.map { normalizedLandmark: NormalizedLandmark -&gt;&#10;            toPixel(normalizedLandmark, imageWidth, imageHeight, pixelDepthScale)&#10;        }&#10;&#10;        // Convert nested objects recursively with explicit type casting&#10;        val pixelObjects = normalizedObj.objects.map { nestedObj: NormalizedObject -&gt;&#10;            toPixel(nestedObj, imageWidth, imageHeight, pixelDepthScale)&#10;        }&#10;&#10;        return Object(&#10;            typeId = normalizedObj.typeId,&#10;            trackingId = normalizedObj.trackingId,&#10;            bounding = pixelBounding,&#10;            landmarks = pixelLandmarks,&#10;            objects = pixelObjects,&#10;            params = normalizedObj.params&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Validates that all coordinates in a NormalizedLandmark are within valid bounds [0,1].&#10;     *&#10;     * @param normalizedLandmark The landmark to validate&#10;     * @param checkZ Whether to also validate the Z coordinate&#10;     * @return True if all coordinates are valid, false otherwise&#10;     */&#10;    fun isValidNormalizedLandmark(normalizedLandmark: NormalizedLandmark, checkZ: Boolean = false): Boolean {&#10;        return CoordinateNormalizer.isValidRelativePoint(normalizedLandmark.location, checkZ)&#10;    }&#10;&#10;    /**&#10;     * Validates that all coordinates in a NormalizedObject are within valid bounds [0,1].&#10;     *&#10;     * @param normalizedObj The object to validate&#10;     * @param checkZ Whether to also validate Z coordinates of landmarks&#10;     * @return True if all coordinates are valid, false otherwise&#10;     */&#10;    fun isValidNormalizedObject(normalizedObj: NormalizedObject, checkZ: Boolean = false): Boolean {&#10;        // Check bounding box&#10;        val boundingValid = normalizedObj.bounding.left in 0.0f..1.0f &amp;&amp;&#10;                normalizedObj.bounding.top in 0.0f..1.0f &amp;&amp;&#10;                normalizedObj.bounding.right in 0.0f..1.0f &amp;&amp;&#10;                normalizedObj.bounding.bottom in 0.0f..1.0f&#10;&#10;        if (!boundingValid) return false&#10;&#10;        // Check landmarks with correct type&#10;        val landmarksValid = normalizedObj.landmarks.all { landmark: NormalizedLandmark -&gt;&#10;            isValidNormalizedLandmark(landmark, checkZ)&#10;        }&#10;&#10;        if (!landmarksValid) return false&#10;&#10;        // Check nested objects recursively with correct type&#10;        val objectsValid = normalizedObj.objects.all { obj: NormalizedObject -&gt;&#10;            isValidNormalizedObject(obj, checkZ)&#10;        }&#10;&#10;        return objectsValid&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package kioskware.vision.landmarks.common&#10;&#10;// This file has been deprecated. &#10;// Normalization methods have been moved to the Landmark and Object classes directly.&#10;// Use landmark.toNormalized() and object.toNormalized() instead." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/scene/NormalizedScene.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/scene/NormalizedScene.kt" />
              <option name="updatedContent" value="package kioskware.vision.landmarks.scene&#10;&#10;import android.graphics.RectF&#10;import kioskware.vision.landmarks.NormalizedLandmark&#10;import kioskware.vision.landmarks.`object`.NormalizedObject&#10;import kioskware.vision.landmarks.`object`.ObjectParam&#10;import kioskware.vision.landmarks.common.Normalized&#10;&#10;/**&#10; * Represents a scene with coordinates in relative [0,1] coordinate system.&#10; * This is a normalized version of [Scene] that implements the [Normalized] interface.&#10; *&#10; * All bounding box coordinates and landmark locations are in relative coordinates [0,1]&#10; * where (0,0) represents the top-left corner and (1,1) represents the bottom-right corner.&#10; */&#10;class NormalizedScene(&#10;    val normalizedLandmarks: List&lt;NormalizedLandmark&gt; = emptyList(),&#10;    val normalizedObjects: List&lt;NormalizedObject&gt; = emptyList(),&#10;    params: List&lt;ObjectParam&lt;*&gt;&gt; = emptyList(),&#10;    val originalWidth: Int,&#10;    val originalHeight: Int,&#10;    val sourceProcessor: SceneImageProcessor&#10;) : Scene(&#10;    landmarks = normalizedLandmarks, // Cast is safe since NormalizedLandmark extends Landmark&#10;    objects = normalizedObjects,     // Cast is safe since NormalizedObject extends Object&#10;    params = params,&#10;    originalWidth = originalWidth,&#10;    originalHeight = originalHeight,&#10;    sourceProcessor = sourceProcessor&#10;), Normalized" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/scene/Scene.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/landmarks/src/main/java/kioskware/vision/landmarks/scene/Scene.kt" />
              <option name="originalContent" value="package kioskware.vision.landmarks.scene&#10;&#10;import android.graphics.RectF&#10;import kioskware.vision.landmarks.Landmark&#10;import kioskware.vision.landmarks.`object`.Object&#10;import kioskware.vision.landmarks.`object`.ObjectParam&#10;&#10;/**&#10; * Constant for scene type id..&#10; */&#10;val TypeIdScene = &quot;@scene&quot;&#10;&#10;/**&#10; * Constant for scene tracking id.&#10; */&#10;val TrackingIdScene = &quot;#scene&quot;&#10;&#10;/**&#10; * Represents a scene in an image containing objects.&#10; * The scene is defined by its source object and its original dimensions.&#10; *&#10; * @property sourceObject The object detected in the scene.&#10; * @property originalWidth The original width of the scene in pixels.&#10; * @property originalHeight The original height of the scene in pixels.&#10; */&#10;open class Scene internal constructor(&#10;    landmarks: List&lt;Landmark&gt;,&#10;    objects: List&lt;Object&gt;,&#10;    params: List&lt;ObjectParam&lt;*&gt;&gt;,&#10;    val originalWidth: Int,&#10;    val originalHeight: Int,&#10;    val sourceProcessor: SceneImageProcessor&#10;) : Object(&#10;    typeId = TypeIdScene,&#10;    trackingId = TrackingIdScene,&#10;    landmarks = landmarks,&#10;    objects = objects,&#10;    params = params,&#10;    bounding = RectF(&#10;        0f,&#10;        0f,&#10;        originalWidth.toFloat(),&#10;        originalHeight.toFloat()&#10;    )&#10;)" />
              <option name="updatedContent" value="package kioskware.vision.landmarks.scene&#10;&#10;import android.graphics.RectF&#10;import kioskware.vision.landmarks.Landmark&#10;import kioskware.vision.landmarks.NormalizedLandmark&#10;import kioskware.vision.landmarks.`object`.Object&#10;import kioskware.vision.landmarks.`object`.NormalizedObject&#10;import kioskware.vision.landmarks.`object`.ObjectParam&#10;import kioskware.vision.landmarks.toNormalized&#10;import kioskware.vision.landmarks.toPixel&#10;import kioskware.vision.landmarks.isValidNormalized&#10;import kioskware.vision.landmarks.`object`.toNormalized as objectToNormalized&#10;import kioskware.vision.landmarks.`object`.toPixel as objectToPixel&#10;&#10;/**&#10; * Constant for scene type id..&#10; */&#10;val TypeIdScene = &quot;@scene&quot;&#10;&#10;/**&#10; * Constant for scene tracking id.&#10; */&#10;val TrackingIdScene = &quot;#scene&quot;&#10;&#10;/**&#10; * Represents a scene in an image containing objects.&#10; * The scene is defined by its source object and its original dimensions.&#10; *&#10; * @property sourceObject The object detected in the scene.&#10; * @property originalWidth The original width of the scene in pixels.&#10; * @property originalHeight The original height of the scene in pixels.&#10; */&#10;open class Scene internal constructor(&#10;    landmarks: List&lt;Landmark&gt;,&#10;    objects: List&lt;Object&gt;,&#10;    params: List&lt;ObjectParam&lt;*&gt;&gt;,&#10;    val originalWidth: Int,&#10;    val originalHeight: Int,&#10;    val sourceProcessor: SceneImageProcessor&#10;) : Object(&#10;    typeId = TypeIdScene,&#10;    trackingId = TrackingIdScene,&#10;    landmarks = landmarks,&#10;    objects = objects,&#10;    params = params,&#10;    bounding = RectF(&#10;        0f,&#10;        0f,&#10;        originalWidth.toFloat(),&#10;        originalHeight.toFloat()&#10;    )&#10;)&#10;&#10;/**&#10; * Converts this scene from pixel coordinates to normalized relative coordinates [0,1].&#10; *&#10; * @param pixelDepthScale Optional scaling factor for z-coordinate conversion&#10; * @return NormalizedScene with coordinates in [0,1] range&#10; */&#10;fun Scene.toNormalized(&#10;    pixelDepthScale: Float = originalWidth.toFloat()&#10;): NormalizedScene {&#10;    // Convert landmarks&#10;    val normalizedLandmarks = this.landmarks.map { landmark -&gt;&#10;        landmark.toNormalized(originalWidth, originalHeight, pixelDepthScale)&#10;    }&#10;&#10;    // Convert objects&#10;    val normalizedObjects = this.objects.map { obj -&gt;&#10;        obj.objectToNormalized(originalWidth, originalHeight, pixelDepthScale)&#10;    }&#10;&#10;    return NormalizedScene(&#10;        normalizedLandmarks = normalizedLandmarks,&#10;        normalizedObjects = normalizedObjects,&#10;        params = this.params,&#10;        originalWidth = this.originalWidth,&#10;        originalHeight = this.originalHeight,&#10;        sourceProcessor = this.sourceProcessor&#10;    )&#10;}&#10;&#10;/**&#10; * Validates that all coordinates in a NormalizedScene are within valid bounds [0,1].&#10; *&#10; * @receiver The scene to validate&#10; * @param checkZ Whether to also validate Z coordinates of landmarks&#10; * @return True if all coordinates are valid, false otherwise&#10; */&#10;fun NormalizedScene.isValidNormalized(checkZ: Boolean = false): Boolean {&#10;    // Check landmarks&#10;    val landmarksValid = normalizedLandmarks.all { landmark -&gt;&#10;        landmark.isValidNormalized(checkZ)&#10;    }&#10;&#10;    if (!landmarksValid) return false&#10;&#10;    // Check objects&#10;    val objectsValid = normalizedObjects.all { obj -&gt;&#10;        obj.isValidNormalized(checkZ)&#10;    }&#10;&#10;    return objectsValid&#10;}&#10;&#10;/**&#10; * Extension function for NormalizedScene to convert back to pixel coordinates.&#10; */&#10;fun NormalizedScene.toPixel(&#10;    pixelDepthScale: Float = originalWidth.toFloat()&#10;): Scene {&#10;    // Convert landmarks&#10;    val pixelLandmarks = this.normalizedLandmarks.map { normalizedLandmark -&gt;&#10;        normalizedLandmark.toPixel(originalWidth, originalHeight, pixelDepthScale)&#10;    }&#10;&#10;    // Convert objects&#10;    val pixelObjects = this.normalizedObjects.map { normalizedObj -&gt;&#10;        normalizedObj.objectToPixel(originalWidth, originalHeight, pixelDepthScale)&#10;    }&#10;&#10;    return Scene(&#10;        landmarks = pixelLandmarks,&#10;        objects = pixelObjects,&#10;        params = this.params,&#10;        originalWidth = this.originalWidth,&#10;        originalHeight = this.originalHeight,&#10;        sourceProcessor = this.sourceProcessor&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>